#!/usr/bin/env python
# (c) 2014 Christiane Ruetten, cr at 23bit net
# licensed under GPLv3
version = "0.1"


# t64 file format, see http://unusedino.de/ec64/technical/formats/t64.html
# pc64 file format, see http://unusedino.de/ec64/technical/formats/pc64.html

import sys
import os
from struct import pack,unpack


class T64File( object ):
	def __init__( self, data=None ):
		self.direntrytype = 0
		self.filetype = 0
		self.startaddr = 0
		self.name = ""
		self.data = ""

		if data is not None:
			self.parse( data )

	def load( self, src=None ):
		if isinstance( src, file ):
			data = file.read()
		elif isinstance( src, str ):
			if os.path.isfile( src ):
				with open( src, "rb" ) as f:
					data = f.read()
			else:
				data = src
		else:
			data = str( src )

		if len(data)<28:
			raise Exception( "invalid data source" )

		magic, zero, filename, zero, relsize, startaddr = unpack( "<7sB16sBBH", data[:28] )

		if magic != "C64File":
			raise Exception( "data not in PC64 format" )

		# unpad filename
		while filename.endswith('\x00'):
			filename = filename[:-1]

		# TODO: determine file type from name
		sys.stderr.write( "WARNING: defaulting to file type $82 (PRG)\n" )
		self.filetype = 0x82

		# rest must be the data
		self.data = data[28:]

	def save( self, dst=None ):
		filename = self.paddedname( '\x00' )
		relsize = 0
		s = pack( "<7sB16sBBH", "C64File", 0, filename, 0, relsize, self.startaddr )
		s += self.data
		if isinstance( dst, file ):
			dst.write( s )
		elif isinstance( dst, str ):
			with open( dst, "wb" ) as f:
				f.write( s )
		else:
			return s

	def paddedname( self, pad=' ' ):
		s = self.name
		if len( s ) > 16:
			s = s[:16] # truncate too long name
			sys.stderr.write( "WARNING: truncating too long file name %s\n" % repr(self.name) )
		return s + pad * (16-len(s))

	def direntry( self , offset ):
		if self.direntrytype == 0:
			return '\x00' * 32
		elif self.direntrytype == 1:
			endaddr = self.startaddr + len(self.data)
			direntry = pack( "<BBHHHLL", self.direntrytype, self.filetype, self.startaddr, endaddr, 0, offset, 0 )
			direntry += self.paddedname()
			return direntry
		else:
			sys.stderr.write( "WARNING: unsupported dir entry type %i. Creating empty entry.\n" % repr(self.direntrytype) )
			return '\x00' * 32

	def filename( self, pos=0 ):
		if self.direntrytype == 0:
			return "<empty>"
		if self.filetype == 0x80:   # DEL
			ext = ".D%02d" % pos
		elif self.filetype == 0x81: # SEQ
			ext = ".S%02d" % pos
		elif self.filetype == 0x82: # PRG
			ext = ".P%02d" % pos
		elif self.filetype == 0x83: # USR
			ext = ".U%02d" % pos
		elif self.filetype == 0x81: # REL
			ext = ".R%02d" % pos
		else:
			ext = ".P%02d" % pos    # fallback for malformed archives
		return self.name + ext


class T64Image( object ):
	"""Holds a T64 image object.
	"""

	signatures = ["C64 tape image file", "C64 tape file", "C64S tape image file", "C64S tape image file"]
	
	def __init__( self, rawdata=None ):
		"""
		Creates a T64 image object.
		Optional parameter is parsed as raw t64 image data.
		Without parameter, an empty image object is created.
		"""

		self.signature = self.signatures[0]
		self.version = 0x100
		self.name = "EMPTY TAPE"
		self.files = []

		if rawdata is not None:
			self.parse( rawdata )

	def parse( self, rawdata ):
		"""
		Parses raw data string as T64 object.
		"""
		# Image header
		p = 0x00
		self.signature = self.unpad( rawdata[p:p+32], '\x00' )
		
		# Directory Header
		p = 0x20
		self.version, direntriesmax, direntriesused, unused = unpack( "<HHHH", rawdata[p:p+8] )
		self.name = self.unpad( rawdata[p+8:p+32], '\x20' )
		dirlist = []
		numfiles = 0
		for i in xrange( direntriesmax ):
			p = 0x40 + 32*i
			direntrytype, filetype, startaddr, endaddr, unused, offset, unused = unpack( "<BBHHHLL", rawdata[p:p+16] )
			if direntrytype == 0:
				dirlist.append( None )
			elif direntrytype == 1:
				name = self.unpad( rawdata[p+16:p+32], '\x20' )
				dirlist.append( { "direntrytype":direntrytype, "filetype":filetype, "startaddr":startaddr, "endaddr":endaddr, "name":name, "offset":offset } )
				numfiles += 1
			else:
				sys.stderr.write( "ERROR: dir entry %i has unsupported type %i. ABORTING\n" % (i,direntrytype) )
				sys.stderr.write( "Please send this .t64 file to the author of this script for analysis.")
				sys.exit( -5 )

		if len( dirlist ) != direntriesmax: # should never happen
			sys.stderr.write( "WARNING: incorrect number of dir entries in header: %i should be %i. FIXED\n" % (direntriesmax,len(dirlist)) )
		if numfiles != direntriesused:
			sys.stderr.write( "WARNING: number of files does not match header info: %i, should be %i. FIXED\n" % (direntriesused,numfiles) )

		# workaround for broken T64 files is to not rely on start and end addresses, but on offsets
		# files with endaddr == 0xc3c6 are probably broken

		offsets = []
		files = {}
		for f in dirlist:
			if f is not None:
				offsets.append( f["offset"] )
				files[ f["offset"] ] = f

		offsets.sort()
		offsets.append( len(rawdata) )
		assert len(offsets) > 1

		for i in xrange( len(offsets)-1 ):
			offset = offsets[i]
			f = files[offset]
			lengthbyoffset = offsets[i+1] - offset
			lengthbyaddress = f["endaddr"] - f["startaddr"] # 2-byte load address is stored in header, but will be part of extracted file
			if lengthbyoffset == lengthbyaddress:
				f["data"] = rawdata[offset:offset + lengthbyaddress]
				f.pop("offset", None)
			else:
				sys.stderr.write( "WARNING: wrong length %i in header, should be %i. FIXED\n" % (lengthbyaddress,lengthbyoffset) )
				f["data"] = rawdata[offset:offset + lengthbyoffset]
				f.pop("offset", None)

		self.files = []
		for f in dirlist:
			if f is None:
				self.files.append( T64File() )
			else:
				n = T64File()
				n.direntrytype = f["direntrytype"]
				n.filetype = f["filetype"]
				n.startaddr = f["startaddr"]
				n.name = f["name"]
				n.data = f["data"]
				self.files.append( n )

	def __getitem__( self, i ):
		return self.files[i]

	def __setitem__( self, i, v ):
		self.files[i] = v

	def load( self, filename ):
		"""
		Parses specified file as T64 image data.
		"""
		if isinstance( filename, file ):
			self.parse( sys.stdin.read() )
		elif isinstance( filename, str ):
			with open( filename, 'rb' ) as f:
				self.parse( f.read() )
		else:
			raise Exception( "object %s is not readable" % repr(filename) )

	def save( self, filename ):
		"""
		Saves T64 image to file.
		"""
		if isinstance( filename, file ):
			filename.write( self.dump )
		elif isinstance( filename, str ):
			with open( filename, 'wb' ) as f: 
				f.write( self.dump() )
		else:
			raise Exception( "object %s is not writable" % repr( filename ) )

	def pad( self, s, pad, l ):
		assert len( pad ) == 1
		if len(s) > l:
			s = s[:l] # truncate too long strings
		return s + pad*(l-len(s))	

	def unpad( self, s, pad ):
		assert len( pad ) == 1
		while s.endswith( pad ):
			s = s[:-1]
		return s

	def info( self ):
		print "#tape name:   %s" % repr( self.name )
		print "#signature:   %s" % repr( self.signature )
		print "#version:     %x" % self.version
		print "#dir entries: %s" % len( self.files )

	def dir( self, verbose=False, pos=False ):
		if verbose:
			self.info()
		for i in xrange(len( self.files )):
			p = self.files[i]
			if p is not None:
				if p.direntrytype != 0:
					if verbose:
						s = "%3i:%02x  $%04x/$%04x %8d " % (i, p.filetype, p.startaddr, p.startaddr+len(p.data), len(p.data) )
					else:
						s = ""
					if pos:
						s += self.name + "/" + p.filename( pos=i )
					else:
						s += self.name + "/" + p.filename()
					print s

	def cleanup( self ):
		self.signature = self.signatures[0]
		self.version = 0x100

		cleanfiles = []
		for f in self.files:
			if f is not None:
				if f.direntrytype == 1:
					cleanfiles.append( f )
		self.files = cleanfiles

	def dump( self ):

		# calculate correct numbers for directory header
		direntriesmax = len(self.files)
		direntriesused = 0
		for f in self.files:
			if f is not None:
				if f.direntrytype != 0:
					direntriesused += 1

		headerdata = self.pad( self.signature, '\x00', 32 )
		headerdata += pack( "<HHHH", self.version, direntriesmax, direntriesused, 0 )
		headerdata += self.pad( self.name, '\x20', 24 )

		dirsize = 32 * len(self.files)
		dirdata = ""
		filedata = ""
		for f in self.files:
			if f is not None:
				offset = len(headerdata) + dirsize + len(filedata)
				dirdata += f.direntry( offset )
				filedata += f.data
			else:
				dirdata += '\x00' * 32

		image = headerdata + dirdata + filedata
		return image

###################################################################################################
# main

def main():
	from optparse import OptionParser

	usage = "usage: %prog {-x | -c | -t | -E | -R} [options] [-f <archive>] [<files>...]"
	parser = OptionParser( usage=usage, version="%prog "+version )
	parser.add_option( "-x", "--extract", action="store_true", dest="extract", default=False, help="extract files from an archive" )
	parser.add_option( "-c", "--create", action="store_true", dest="create", default=False, help="create a new archive" )
	parser.add_option( "-t", "--list", action="store_true", dest="list", default=False, help="list the contents of an archive" )
	parser.add_option( "-E", "--edit", action="store_true", dest="edit", default=False, help="edit an archive interactively" )
	parser.add_option( "-R", "--repair", action="store_true", dest="repair", default=False, help="repair a malformed archive" )
	parser.add_option( "-p", "--position", action="store_true", dest="keep_position", default=False, help="encode position in file names" )
	parser.add_option( "-v", "--verbose", action="store_true", dest="verbose", default=False, help="verbose operation" )
	parser.add_option( "-q", "--quiet", action="store_true", dest="quiet", default=False, help="suppress warnings" )
	parser.add_option( "-f", "--file", dest="filename", help="verbose operation" )

	# support old-style "tvf" tar arguments
	if len(sys.argv)>1 and not sys.argv[1].startswith( '-' ):
		sys.argv[1] = '-' + sys.argv[1]
	(opt, args) = parser.parse_args()

	##############################################################################
	if opt.list:
		t = T64Image()
		if opt.filename:
			t.load( opt.filename )
		else:
			t.load( sys.stdin )
		if opt.repair:
			t.cleanup()
		t.dir( verbose=opt.verbose, pos=opt.keep_position )

	##############################################################################
	elif opt.extract:
		t = T64Image()
		if opt.filename:
			t.load( opt.filename )
		else:
			t.load( sys.stdin )
		if opt.repair:
			t.cleanup()
		print "ERROR: extraction not implemented"

	##############################################################################
	elif opt.create:
		t = T64Image()
		print "ERROR: archive creation not implemented"

	##############################################################################
	elif opt.edit:
		t = T64Image()
		if not opt.filename:
			sys.stderr.write( "ERROR: edit mode requires file argument" )
		else:
			t.load( opt.filename )
			if opt.repair:
				t.cleanup()

			print "Welcome to the 64ar interactive python shell."
			print "The archive is as the t object."
			print "Type ?t for usage info."
			print
			t.dir( verbose=True )
			print

			from IPython.terminal.embed import InteractiveShellEmbed
			ipshell = InteractiveShellEmbed( banner1="ready.", exit_msg="bye." )
			ipshell.confirm_exit = False
			ipshell()

			print "Do you want to save changes (y/[n])? ",
			l = sys.stdin.readline()
			if l.startswith( "y" ):
				t.save( opt.filename )
				print "saved."
			print

	##############################################################################
	elif opt.repair:
		t = T64Image()
		if opt.filename:
			t.load( opt.filename )
			t.cleanup()
			t.save( opt.filename )
		else:
			t.load( sys.stdin )
			t.cleanup()
			t.save( sys.stdout )

	##############################################################################
	else:
		sys.stderr.write( 'ERROR: you must specify a valid command\n' )
		sys.exit( -5 )

if __name__ == '__main__':
	main()